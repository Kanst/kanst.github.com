---
layout: post
title: Типо обзор ОС ArchLinux. سمَـَّوُوُحخ ̴̐خ ̴̐خ ̴̐خ امارتيخ ̴̐خ
category : trash
tags : [Linux, ArchLinux, OS, vse_ploho]
---
{% include JB/setup %}

__________________________________

#Домашнее задание по курсу «Операционные Системы».  

##1.  История появления операционной системы.  
**Arch Linux** был основан канадским программистом Джаддом Вайнетом (англ. Judd Vinet). Первый релиз был выпущен 11 марта 2002 года. Arch является независимым дистрибутивом, хотя и используют принципы таких операционных систем, как **BSD**, **Slackware**, **CRUX**. В 2007 году Джадд Вайнет ушел с поста руководителя проекта, его заменил Аарон Гриффин (англ. Aaron Griffin), который продолжает руководить проектом на сегодняшний день.  

##2.Структура операционной системы.  
Данный дистрибутив придерживается собственной философии The Arch Way ("Путь Arch"). Он является легковесным, гибким, и максимольно UNIX-подобным дистрибутивом. Поддерживаются платформы i686 и x86-64. Сразу после установки пользователю предоставляется среда без графического интерфейса и с минимальным количеством пакетов. В результате чего пользователь имеет возможность самостоятельно построить систему для своих нужд. Arch несколько отличается от других дистрибутивов загрузкой стартовых скриптов. До 04.08.2012 использовался BSD стиль загрузки стартовых скриптов, а не System V. В настоящее время используется система инициализации systemd.  

Процессы в **ArchLinux** имеют много характеристик, которые будут рассмотрены в пункте 4. В частности, PID, приоритет, сигналы контроля выполнения процессами, таблицу процессов и некоторые другие. Жизненный цикл процесса можно описать следующим образом *fork -> exec -> exit* (более подробно в п.4). Потоки реализуются с помощью системного вызова **clone**.  

Каждая программа в **ArchLinux** имеет свое адресное пространство, в которое входят такие сегменты, как сегмент программы, данных и стека. Сегмент программы содержит машинный код, который создается при трансляции программы, написанной на языке высокого уровня. Сегмент данных сожержит переменные программы. В арче реализована страничная подкачка, которая позволяет ускорить работу процессов. Идея состоит в следующем: чтобы процесс выполнялся он не должен полностью находиться в памяти (более подробно в п.4).  

Как правило, все устройства ввода-вывода выглядят как в файлы (в Linux все является файлами, даже процессы). Сдедовательно доступ к ним происходит аналогично. В ArchLinux все устройства интегрируются в систему в виде специальных файлов (блочных и символьных).  Также  ввод-вывод испрользуется при работе с сетью. Для этого используются порты и сокеты (более подробно в п.4).  

Файловая система Linux  представляет собой единое дерево, начинающееся с корневого каталога (/). В ArchLinux многообразие каталогов и их содержание регламентируется специальным стандартом иерархии файловой системы (FHS) для unix-подобных операционных систем.  
<div align="center"><img src="/images/img00002.gif"></div>   

##3. Интерфейс операциооной системы.  
В ArchLinux пользователь может работать через интерфейс командной строки (CLI), графический интерфейс пользователя (GUI), или, в случае встраиваемых систем, через элементы управления соответствующих аппаратных средств. После установки системы у пользователя настроена только командная строка, т.к. философия данного дистрибутива основанна на гибкости и, следоовательно, пользователь сам должен выбрать свой вариант графического интерфейса. Но нередко пользователи ArchLinux используют  CLI.  
На настольных системах (на серверных обычно не использую пользовательских интерфейсов) наибольшей популярностью пользуются пользовательские интерфейсы, основанные на таких средах рабочего стола как KDE Plasma Desktop, GNOME и Xfce, хотя также существует целый ряд других пользовательских интерфейсов. Самые популярные пользовательские интерфейсы основаны на X Window System (часто просто «X» или «иксы»).  
Другие графические интерфейсы, такие как FVWM, Enlightenment и Window Maker, могут быть классифицированы как простые менеджеры окон X Window System, которые предоставляют окружение рабочего стола с минимальной функциональностью.  
Оконный менеджер предоставляет средства для управления размещением и внешним видом отдельных окон приложений, а также взаимодействует с X Window System.  
Окружение рабочего стола включает в себя оконные менеджеры, как часть стандартной установки: (Metacity для GNOME, KWin для KDE, Xfwm для Xfce с 2010 года), хотя пользователь при желании может выбрать другой менеджер окон. 
Рассмотрим некоторые интерфейсы:  

Gnome (GNU Network Object Model Environment) — самая популярная среда рабочего стола для Linux. Gnome является одной из самых функциональных рабочих сред и включает в себя набор утилит для настройки среды, прикладное программное обеспечение, системные утилиты и другие модули.  
<div align="center"><img src="/images/1.jpg"></div>    

KDE — полнофункциональная среда рабочего стола. В рамках проекта KDE разрабатывается большое количество приложений для повседневных нужд. Рабочий стол KDE изобилует различными графическими эффектами. KDE использует библиотеки Qt.  
<div align="center"><img src="/images/2.jpg"></div>  

LXDE (Lightweight X11 Desktop Environment) — быстрая легковесная среда рабочего стола, не требовательная к ресурсам компьютера. В качестве оконного менеджера используется Openbox. Окна и меню открываются без задержек, интерфейс отзывчивый и не вызывает раздражения.  
<div align="center"><img src="/images/2.jpg"></div>  

Xfce — легковесное рабочее окружение не требовательное к ресурсам компьютера. Имеет современный интерфейс и при этом потребляет мало оперативной памяти. Xfce содержит набор базового программного обеспечения для комфортной работы. Для настройки среды используются графические утилиты.  
<div align="center"><img src="/images/2.jpg"></div>  


##4. Реализация операциооной системы. 
Ядро — это часть операционной системы, которая организует доступ к аппаратным средствам через абстрактный высокоуровневый программный интерфейс. Ядро отвечает за реализацию многих концепций, которые пользователями и программами пользова­тельского уровня принимаются как нечто само собой разумеющееся. В частности, на базе низкоуровневых аппаратных возможностей ядро реализует следующие элементы операционной системы ArchLinux:
  
+  процессы (защита адресных пространств, разделение времени и ресурсов процес­сора);  
+  сигналы и семафоры;  
+  виртуальную память (подкачка, страничный обмен, отображение виртуальных адресов в физической памяти);  
+  файловую систему (файлы, каталоги, пространство имен);  
+  общий ввод-вывод (специализированное оборудование, клавиатура, мышь, USB);  
+  межзадачное взаимодействие (каналы и сетевые соединения).  

Ядро содержит драйверы устройств, которые организуют взаимодействие с отдельными элементами аппаратного уровня; остальная часть ядра, в основном, не зависит от внешних устройств. Взаимосвязь ядра и драйверов устройств аналогична связи между ядром и процессами пользовательского уровня.  
Ядро написано преимущественно на языке С, хотя в некоторых случаях иcспользуется язык ассемблера, что позволяет вызывать специализированные функции устройств, не доступные через обычные директивы компилятора.  
Ядро Linux поддерживает многозадачность, виртуальную память, динамические библиотеки, отложенную загрузку, производительную систему управления памятью и многие сетевые протоколы.  
На сегодняшний день Linux — монолитное ядро с поддержкой загружаемых модулей. Драйверы устройств и расширения ядра обычно запускаются в 0-кольце защиты, с полным доступом к оборудованию. В отличие от обычных монолитных ядер, драйверы устройств легко собираются в виде модулей и загружаются или выгружаются во время работы системы.  
То, что архитектура Linux не является микроядерной, вызвало обширнейшие прения между Линусом Торвальдсом и Эндрю Таненбаумом в конференции comp.os.minix  

###4.1. Реализация процессов и потоков.
*Процесс* - это системный объект, посредством которого можно контролировать обращение программы к памяти, ЦП, к операциям ввода-вывода. Философия Unix подразумевает, что как можно больше работы должны выполняться в контексте процессов, а не в ядре.  
На выполнение процесса влияют многие характеристики. В частности, большое значение имеет, сколько времени выделяется процессу центральным процессором, к каким файлам обращается процесс, значение идентификатора родительского процесса. Эти и некоторые другие характеристики будут рассмотрены далее.  
####Идентификатор процесса (PID) и идентификатор родительского процесса (PPID).
Каждый процесс имеет свой идентификатор. Идентификаторы назначаются ядром по мере создания процессов.  
В Unix нет вызовов, которые бы создавали новый процесс. Для того, чтобы создать новый процесс, один из существующих должен клонировать себя. При этом клон - дочерний процесс, а исходный процесс - родительский. Дочерний процесс может изменить выполняемую программу. При создании процесса, дочернему присваивается идентификатор родительского процесса (PPID), помимо обычного PID. Если родительский процесс завершится раньше дочернего, то шефство берет демон *init* (PPID дочернего процесса будет равен 1).  
Идентификатор родительского процесса - очень полезная информация для системного администратора. Если приходится иметь дело с неизвестным процессом, то отслеживание предка может облегчить понимание назначения этого процесса.

Также процесс имеет такие характеристики, как идентификатор пользователя (UID), текущий идентификатор пользователя (EUID), идентификатор группы (GID), текущий идентификатор группы (EGID).  

####Фактор уступчивости и приоритет.
С помощью динамического алгоритма вычисления приоритета, ядро определяет, какую долю центрального процессора получает программа. Кроме того учитывается заданный администратором фактор уступчивости, который определяет возможность "деления" своим временем с другими процессами. Чем выше фактор уступчивости, тем ниже приоритет процесса. Диапазон значений зависит от используемой системы. Обычно лежит в пределах -20..+19 (0..39).  
В настоящее время администраторам редко приходится определять значение фактора уступчивости. Если какой-либо процесс занимает большое время ЦП, то для исследования проблемы (например, с помощью команды **top**) нужно повысить приоритет этой команды (понизить фактор уступчивости). 
Команда **nice** позволяет задать приоритет при создании процесса. **renice** же позволяет изменять приоритет выполняемого процесса.  
Примеры: 


    $ nice -n 5 top     //Запускаем программу с пониженным приоритетом.
    $ renice -5 3456    //Фактор уступчивости процесса равен -5.
    $ renice -5 -u kanst9 //Фактор уступчивости процессов пользователя kanst9 равен -5.

####Жизненный цикл процессов.    
Для создания нового процесса существующий процесс клонирует самого себя с помощью системного вызова fork. Результатом является получение копии исходного процесса, имеющей лишь некоторые отличия. В частности, новому процессу присваивается новый идентификатор, и учет ресурсов ведется для него независимо от предка.  

Системный вызов fork обладает уникальным свойством: он возвращает сразу два значения. В порожденном процессе эта функция возвращает 0, а в родительском — идентификатор потомка. Поскольку в остальном процессы идентичны, они должны проверять это значение, чтобы определить, в какой роли следует выступать дальше.  

После выполнения системного вызова fork новый процесс обычно запускает новую программу с помощью одного из системных вызовов семейства exec. Все вызовы семейства exec производят приблизительно одинаковые действия: они замещают сегмент кода процесса и устанавливают сегменты данных и стека в исходное состояние. Формы вызовов exec отличаются только способами указания аргументов командной строки и переменных среды, передаваемых новой программе.  

Когда система загружается, ядро самостоятельно создает несколько процессов. Наиболее важный из них — процесс init, идентификатор которого всегда равен 1. Программа init отвечает за вызов командного интерпретатора для выполнения стартовых сценариев, если они используются в системе. Все процессы, кроме тех, что создаются ядром, являются потомками процесса init.  

 Программа init играет и другую важную роль в управлении процессами. Когда процесс завершается, он вызывает функцию _exit(), чтобы уведомить ядро о своей готовности прекратить работу. В качестве параметра функции _exit() передается код завершения — целое число, указывающее на причину останова процесса. По соглашению нулевой код завершения означает, что процесс окончился успешно.  
 В UNIX требуется, чтобы, прежде чем процесс окончательно исчезнет, его удаление было подтверждено родительским процессом с помощью системного вызова wait. Данная функция возвращает код завершения потомка и, если требуется, статистику использования ресурсов. По этой причине ядро должно хранить код завершения, пока родительский процесс не запросит его. По окончании дочернего процесса его адресное пространство освобождается, время центрального процессора ему не выделяется, однако в таблице процессов ядра сохраняется запись о нем. Процесс в этом состоянии называется зомби.  

 Описанный механизм работает нормально, если родительский процесс завершается позже порожденных им процессов и добросовестно выполняет системные вызовы wait для того, чтобы все процессы-зомби были уничтожены. Если же родительский процесс завершается первым, то ядро понимает, что вызова wait не последует, и переназначает все процессы-зомби программе init. Она обязана принять "осиротевшие" процессы и ликвидировать их, осуществив для каждого из этих процессов вызов wait.  

 Раньше программа init не всегда выполняла свои обязанности как следует и зомби оставались в системе. В последнее время, однако, подобных проблем мы не замечали.  

####Сигналы.
Сигналы - один из способов межпроцессорного взаимодействия. Список сигналов можно получить с помощью команды **kill -l**. А их подробное описание с помощью команды **man signal**.
Рассмотрим самые популярные сигналы:

+ 1 - **HUP** - отбой (многие демоны используют этот сигнал, как команду перечитать их конфигурационный файл и продолжить работу с измененными настройками).  
+ 2 - **INT** - прерывание (генерируется нажатием клавиш "Ctrl+C").  
+ 3 - **QUIT** - выход (напоминает сигнал **TERM**, только создается дамп памяти).  
+ 9 - **KILL** - уничтожение (этот сигнал не блокируется и не перехватывается и приводит к безусловному завершению процесса).  
+   - **BUS** и **SEGV** - посылаются при возникновении ошибок на шине и ошибок сегментации.  
+ 15 - **TERM** - запрос на завершение (процесс, получивший этот сигнал, осуществляет очистку и завершается).  
+   - **STOP** - остановка (приостанавливает процесс до получения сигнала **CONT**, нельзя перехватить и заблокировать).  
+   - **TSTP** - остановка с клавиатуры (посылается нажатием клавиш "Ctrl+Z").
+   - **CONT** - продолжение после останова (нельзя заблокировать).  

Чтобы послать сигнал часто используют команду **kill**. Она имеет следующий синтаксис:  
  kill [-сигнал]  идентификатор.
  Команда killall уничтожает процессы, заданные именем.
    $ killall top 

    С помощью команды **trap** можно перехватывать сигналы. Рассмотрим на примере:

    $ trap "echo Получен сигнал INT" INT
    $ <Ctrl+C>
    $ Получен сигнал INT


Команды **ps** и **top** считывают информацию из каталога **/proc**. Большинство файлов этого каталога выглядят пустыми, так как ядро создает содержимое на лету. Рассмотрим содержимое каталога **/proc**.  

+ **cmdline** - Полная командная строка процесса.  
+ **cwd** - Символьная ссылка на текущий каталог процесса.  
+ **exe** - Символьная ссылка на файл, который должен выполняться.  
+ **fd** - Подкаталог, содержащий ссылки на дескрипторы каждого открытого файла.  
+ **maps** - Информация отображения памяти.  
+ **root** - Символьная ссылка на корневой каталог процесса.  
+ **stat** - Информация об общем состоянии процесса.  
+ **statm** - Информация об используемой памяти.  

Более подробно про каталог **/proc** можно посмотреть с помощью команды **man proc**.  

####Потоки.
Операционная система Linux поддерживает потоки в ядре довольно интересным способом. Эта реализация основана на идеях из системы 4.4BSD, но в дистрибутиве 4.4BSD потоки на уровне ядра реализованы не были, так как у Университета Калифорнии в Беркли деньги кончились раньше, чем библиотеки языка С могли быть переписаны так, чтобы решить описанные выше проблемы.   
Исторически процессы были контейнерами ресурсов, а потоки — единицами исполнения. Процесс содержал один или несколько потоков, которые совместно использовали адресное пространство, открытые файлы, обработчики сигналов и все остальное. Все было понятно и просто. В 2000 году в Linux был введен новый мощный системный вызов clone, который размыл отличия между процессами и потоками и, возможно, даже инвертировал первенство этих двух концепций. Вызова clone нет ни в одной другой версии UNIX.   
Классически, при создании нового потока исходный поток (потоки) и новый  поток совместно использовали все, кроме регистров, — в частности, дескрипторы для открытых файлов, обработчики сигналов, прочие глобальные свойства — все это было у каждого процесса, а не у потока. Системный вызов clone дал возможность все эти аспекты сделать специфичными как для процесса, так и для потока. Формат вызова выглядит следующим образом:   
	pid = clone(function, stack_ptr, sharing_flags. arg);   
Вызов clone создает новый поток либо в текущем процессе, либо в новом  процессе (в зависимости от флага sharing_flags). Если новый поток находится в  текущем процессе, то он совместно с существующими потоками использует адресное пространство и каждая последующая запись в любой байт адресного пространства (любым потоком) тут же становится видима всем остальным потокам процесса.   
С другой стороны, если адресное пространство совместно не используется, то новый поток получает точную копию адресного пространства, но последующие записи из нового потока уже не видны старым потокам. Здесь используется та же семантика, что и у системного вызова fork по стандарту POSIX. 
В обоих случаях новый поток начинает выполнение функции function с  аргументом arg в качестве единственного параметра. Также в обоих случаях новый поток получает свой собственный приватный стек, при этом указатель стека  инициализируется параметром stack jptr.   
Параметр sharing_flags представляет собой битовый массив, обеспечивающий существенно более тонкую настройку совместного использования, чем  традиционные системы UNIX. Каждый бит может быть установлен независимо от остальных и каждый из них определяет, копирует ли новый поток эту структуру данных или Бит CLONE_ VM определяет, будет ли виртуальная память (то есть адресное  пространство) использоваться совместно со старыми потоками или будет  копироваться. Если этот бит установлен, то новый поток просто добавляется к старым потокам, так что в результате системный вызов clone создает новый поток в существующем процессе. Если этот бит сброшен, то новый поток получает свое собственное приватное адресное пространство. Это означает, что результат выданных из него команд процессора STORE не виден существующим потокам. Такое поведение  подобно поведению системного вызова fork. Создание нового адресного пространства равнозначно определению нового процесса.   
<div align="center"><img src="/images/6.PNG"></div>   

Бит CLONEFS управляет совместным использованием рабочего каталога и  каталога root, а также флага umask. Даже если у нового потока есть свое собственное адресное пространство, при установленном бите CLONEFS старый и новый  потоки будут совместно использовать рабочие каталоги. Это означает, что вызов chdir одним из потоков изменит рабочий каталог другого потока, несмотря на то, что у другого потока есть свое собственное адресное пространство. В системе UNIX вызов chdir потоком всегда изменяет рабочий каталог всех остальных потоков этого процесса, но никогда не меняет рабочих каталогов других процессов. Таким образом, этот бит обеспечивает такую разновидность совместного использования, которая недоступна в традиционных версиях UNIX.   
Бит CLONEFILES аналогичен биту CLONEFS. Если он установлен, то новый поток предоставляет свои дескрипторы файлов старым потокам — так что  вызовы Iseek одним потоком становятся видимыми для других потоков, — что также обычно справедливо для потоков одного процесса, но не для потоков различных процессов. Аналогично бит CLONESIGHAND разрешает или запрещает совместное использование таблицы обработчиков сигналов старым и новым потоками. Если таблица общая (даже для потоков в различных адресных пространствах) — тогда изменение обработчика в одном потоке повлияет на обработчики в других потоках.   
Бит CLONEPID указывает, получит ли новый поток свой собственный PID или будет использовать PID своего родительского потока. Это свойство нужно при загрузке системы. Процессам пользователя не разрешается использовать этот бит.   
И наконец, каждый процесс имеет родителя. Бит CLONEPARENT управляет тем, кто является родителем нового потока. Это может быть родитель вызывающего потока (в таком случае новый поток является братом вызывающего потока), либо это может быть сам вызывающий поток (в таком случае новый поток являетсяпотомком вызывающего). Есть еще несколько битов, которые управляют другими вещами, но они не так важны.  
Такая детализация вопросов совместного использования стала возможна  благодаря тому, что в системе Linux для различных элементов (параметры планирования, образ памяти и т. д.), используются отдельные структуры данных. Структура  задач просто содержит указатели на эти структуры данных, поэтому легко создать новую структуру задач для каждого клонированного потока и сделать так, чтобы она указывала либо на структуры (планирования потоков, памяти и пр.)  старого потока, либо на копии этих структур. Сам факт возможности такой высокой степени детализации совместного использования еще не означает, что она полезна — особенно потому, что в традиционных версиях UNIX это не поддерживается. Если какая-либо программа в системе Linux пользуется этой возможностью, то это означает, что она больше не является переносимой на UNIX. Модель потоков Linux порождает еще одну трудность. UNIX-системы  связывают с процессом один PID (независимо от того, однопоточный он или  многопоточный). Чтобы сохранять совместимость с другими UNIX-системами, Linux различает идентификаторы процесса PID и идентификаторы задачи TID. Оба этих поля хранятся в структуре задач. Когда вызов clone используется для создания нового процесса (который ничего не использует совместно со своим создателем), PID устанавливается в новое значение; в противном случае задача получает новый TID, но наследует PID. Таким образом все потоки процесса получат тот же самый PID, что и первый поток процесса.использует ее совместно с вызывающим потоком.   

###4.2.Взаимоблокировка 
Блокировкой процессов называют такое состояние системы, при котором 2 или более процессов не могут продолжать свое выполнение из-за отсутствия необходимых для этого ресурсов.  
Взаимоблокировка возникает в многозадачных многопользовательских ОС. Чем большее количество различных задач выполняется на машине, и чем меньше ее ресурсы, тем больше вероятность возникновение взаимоблокировок. При этом ситуация напоминает подающий с горы снежный ком. Количество блокированных процессов быстро возрастает до тех пор, пока в системе не останется не одного работающего процесса. ОС практически полностью прекращает полезное функционирование а ЭВМ простаивает.  
Блокировки процессов возникают либо сами собой, либо инициализируются внешними атаками. Например: атаки вирусов (хакеров) на определенный сайт приводят к возникновению блокировки на обслуживающим этот сайт ЭВМ. Это вызвано перегрузкой работы соответствующей ЭВМ, когда в условии ограниченности ресурсов (хотя эти ресурсы у майнфреймов могут быть очень большими: несколько сотен дисков, десятки терабайт ОП и т.д. ) ЭВМ должна одновременно обработать очень большое количество запросов.  

Имеются различные способы выхода из блокировок:  

1. Снятие оператором выполняющихся процессов до тех пор, пока не исчезнет взаимоблокировка. Этот путь эффективен лишь в том случае, когда количество выполняющихся процессов не очень велико (например не более 100). При большом количестве выполняющихся процессов этот путь чаще всего не помогает преодолеть блокировку.  
2. Перезагрузка системы этот путь преодоления блокировок наиболее радикальный, но и наиболее дорогой.  
3. Рестарт системы с так называемой контрольной точки.  

Имеются два противоположных способа борьбы с взаимоблокировками:

1. Полное игнорирование угроз возникновения взаимоблокировок.  
2. Построение такой ОС, которая просчитывает на несколько шагов вперед (подобно шахматисту) ситуацию которая может возникнуть в ЭВМ после запуска определенного процесса. Это можно сделать на основе теории графов. Такое построение ОС ведет к существенному усложнению ее структуры, однако не решает проблемы на 100%, поскольку любая сложная программа, в том числе и ОС, имеет большое количество не выявленных ошибок. В типичных ОС количество ошибок исчисляется несколькими десятков или сотнями тысяч.  

Игнорирование угрозы взаимоблокировок приводит к тому, что ОС плохо контролирует последовательность выделения ресурсов отдельным процессам, поэтому с течением времени неизбежно возникновение блокировки.
Почти все ОС построены по такому принципу. **ArchLinux** не исключение. На майнфреймах, при проектировании, такая структура ОС была принята , что при среднем количестве запросов на ЭВМ и большом объеме ее ресурсов возникновение блокировок было маловероятным. Затраты на написание сложной безопасной ОС представлялись проектировщиками гораздо больше чем экономические потери возникающие из-за редких возникновении взаимоблокировок. Однако с появлением вирусов и хакерских атак вероятность перегрузки ЭВМ и возникновение блокировок очень сильно возросла. 
 

###4.3.Управление памятью.
<div align="center"><img src="/images/7.PNG"></div>   
Стандарт POSIX системные вызовы для управления памятью не определяет.    
<div align="center"><img src="/images/8.PNG"></div>   
Системные вызовы mmap и unmap управляют отображением файлов на адресное пространство памяти. Первый параметр addr системного вызова mmap указывает адрес, по которому будет отображаться файл (или его часть). Он должен быть кратен размеру страницы. Если этот параметр равен 0, то операционная система определяет этот адрес сама и возвращает его в а. Второй параметр — len — задает количество отображаемых байтов. Он также должен быть кратен размеру страницы.  Третий параметр — prot — задает режим защиты для отображаемого файла. Файл может быть помечен как доступный для чтения, записи, исполнения — или любой комбинацией этих трех битов. Четвертый параметр —flags — определяет, является ли отображаемый файл приватным или доступным для совместного  использования, а также содержит ли параметр addr жесткое требование или это всего лишь подсказка. Пятый параметр —fd— представляет собой дескриптор отображаемого файла. Отображаться могут только открытые файлы. Наконец, параметр offset  сообщает, с какого места должен отображаться файл. Файл может быть отображен начиная с границы страницы.      
Второй системный вызов — unmap — отменяет отображение файла на память. Если отменяется отображение только части файла, то остальная часть файла  продолжает отображаться на память.    
Чтобы механизм подкачки был эффективен на архитектурах х32 и х64, система Linux использует четырехуровневую страничную организацию. Трехуровневая схема была реализована в системе для процессора Alpha, она была расширена  после версии Linux 2.6.10, и начиная с версии 2.6.11 используется четырехуровневая схема. Каждый виртуальный адрес разбивается на пять полей. Поля каталогов используются как индекс в соответствующем каталоге страниц (каждый процесс имеет свой приватный каталог). Обнаруженное  значение является указателем на один из каталогов следующего уровня, которые тоже проиндексированы полем из виртуального адреса. Выбранный элемент среднего каталога страниц указывает на окончательную таблицу страниц,  проиндексированную полем страницы из виртуального адреса. Найденный здесь элемент содержит указатель на нужную страницу. На компьютерах с процессором Pentium используется только двухуровневая организация страниц. В этом случае каждый из верхних и средних каталогов страниц содержит только одну запись. Таким образом, элемент глобального каталога фактически указывает на таблицу страниц. При необходимости может использоваться и трехуровневая страничная  организация, для этого размер поля верхнего каталога страниц устанавливается в нуль.  
Физическая память используется для различных целей. Само ядро жестко фиксировано — ни одна его часть никогда не выгружается на диск.   

####Алгоритм выделения памяти 
ArchLinux поддерживает несколько механизмов выделения памяти. Главным  механизмом для выделения новых страничных блоков физической памяти является распределитель страниц (page allocator), который работает при помощи широко известного «приятельского» алгоритма. Основная идея управления блоками памяти заключается в следующем.  Изначально память состоит из единого непрерывного участка. Когда поступает запрос на выделение памяти, он сначала округляется до степени двух, например до 8 страниц.  
Затем весь блок памяти делится пополам. Так как получившиеся в результате этого деления участки памяти все еще слишком велики, нижняя  половина делится пополам еще и еще. Теперь мы получили участок памяти нужного размера, поэтому он предоставляется вызвавшему процессу.    
Этот алгоритм приводит к существенной внутренней фрагментации, так как, если вам нужен 65-страничный участок, то вы должны будете запросить и получите 128-страничный блок. Чтобы решить эту проблему, в системе ArchLinux есть второй механизм выделения памяти — распределитель фрагментов (slab allocator), выбирающий блоки памяти при помощи «приятельского» алгоритма, а затем нарезающий из этих блоков более мелкие куски и управляющий этими более мелкими кусками по отдельности.   

####Подкачка
Подкачка реализована частично ядром и частично новым процессом,  называемым демоном страниц (page daemon). Демон страниц — это процесс 2 (процесс 0 — это процесс idle — традиционно называемый своппером, а процесс 1 — это init. Как и все демоны, демон страниц работает периодически. После пробуждения он осматривается — есть ли для него работа. Если он видит, что количество страниц в списке свободных слишком мало, то он начинает  освобождать страницы. Операционная система Linux является системой с подкачкой страниц по  требованию (без упреждающей подкачки) и без концепции рабочего набора (хотя в ней есть системный вызов для указания пользователем страницы, которая ему может 
скоро понадобиться). Файлы подкачки могут динамически добавляться и удаляться, и у каждого есть свой приоритет. Страницы на устройстве подкачки или разделе подкачки не выделяются до тех пор, пока они не потребуются. Каждое устройство или файл подкачки  начинается с битового массива, в котором сообщается, какие страницы свободны. Когда страница, у которой нет резервного хранения на диске, должна быть удалена из памяти, то из разделов (или файлов) подкачки, в которых еще есть свободное  место, выбирается раздел (или файл) с наивысшим приоритетом, и в нем выделяется страница. Как правило, раздел подкачки (если таковой имеется) имеет более  высокий приоритет, чем любой файл подкачки. Таблица страниц обновляется, чтобы отразить тот факт, что страница больше не присутствует в памяти (то есть устанавливается бит «страница отсутствует») и ее местоположение на диске записывается в элемент таблицы страниц.     
###4.4.Устройства ввода-вывода.
Ввод-вывод в операционной системе Linux реализуется набором драйверов устройств, по одному для каждого типа устройств. Функция драйвера заключается в изолировании остальной части системы от особенностей аппаратного  обеспечения. При помощи стандартных интерфейсов между драйверами и остальной  операционной системой основная часть системы ввода-вывода может быть помещена 
в машинно-независимую часть ядра.    
Когда пользователь обращается к специальному файлу, файловая система  определяет номера старшего и младшего устройств, а также выясняет, является ли файл блочным специальным файлом или символьным специальным файлом. Номер старшего устройства используется в качестве индекса для одной из двух  
внутренних хэш-таблиц, содержащих структуры данных для блочных (или символьных) специальных файлов. Найденная таким образом структура содержит указатели на процедуры открытия устройства, чтения из устройства, записи на устройство и т. д. Номер младшего устройства передается в виде параметра. Добавление  нового типа устройства в системе Linux означает добавление нового элемента к одной 
из этих таблиц, а также предоставление соответствующих процедур выполнения различных операций с устройством.    

<div align="center"><img src="/images/9.PNG"></div>   
Система ввода-вывода разделена на два основных компонента: обработку  блочных специальных файлов и обработку символьных специальных файлов. 
Цель той части системы, которая занимается операциями ввода-вывода с **блочными** специальными файлами (например, дисками), заключается в  минимизации количества операций передачи данных. Для достижения данной цели в Linux-системах между дисковыми драйверами и файловой системой имеется кэш. Обобщенный уровень блоков связывает эти компоненты вместе и выполняет необходимые  преобразования между дисковыми секторами, блоками, буферами и страницами данных.  
Взаимодействие с **символьными** устройствами простое. Поскольку символьные устройства потребляют или производят потоки символов (или байтов данных), то поддержка произвольного доступа не имеет смысла. Исключение — использование дисциплины линии (line disciplines). Дисциплина линии связи может быть связана с терминальным устройством (представленным структурой ttyjstruct) и работает как интерпретатор для данных, обмен которыми происходит с терминальным устройством. Например, можно делать локальное строковое редактирование  (удалять стертые пользователем символы и строки), символы возврата каретки можно заменять символами переноса строки, а также выполнять другие специальные  операции обработки. Однако если процесс желает воспринимать каждый введенный пользователем символ, то он может перевести линию в необрабатываемый режим (минуя дисциплину линии связи). Не все устройства имеют дисциплину линии связи.   
Вывод работает аналогично, заменяя знаки табуляции пробелами, добавляя перед символами переноса строки символы возврата каретки, добавляя для  медленных механических терминалов символы-заполнители, за которыми следует символ возврата каретки и т. д. Как входной, так и выходной символьный поток может быть пропущен через дисциплину линии связи (обработанный режим) или миновать ее (необработанный режим). Необработанный режим особенно полезен при отправке двоичных данных на другие компьютеры по последовательной  линии или для графических интерфейсов пользователя. Здесь не требуется никакого преобразования.  
Взаимодействие с **сетевыми устройствами (network devices)** несколько  отличается. Сетевые устройства также производят и потребляют потоки символов, однако асинхронная природа делает их не очень подходящими для интеграции в один интерфейс с другими символьными устройствами. Драйвер сетевого  
устройства производит пакеты, состоящие из большого количества байтов (они имеют также сетевые заголовки). Эти пакеты затем маршрутизируются через несколько драйверов сетевых протоколов и в конечном итоге передаются в пользовательское приложение. Ключевой структурой данных здесь является структура буфера сокета skbuff, которая используется для представления областей памяти, заполненных данными пакетов. Данные в буфере skbuff не всегда начинаются с начала буфера. При их обработке различными протоколами сетевого стека могут как добавляться, так и удаляться заголовки протоколов. Пользовательские процессы взаимодействуют с сетевыми устройствами через вызов sockets, который в Linux поддерживает исходный интерфейс прикладного программирования BSD. Драйверы протоколов можно обойти и получить прямой доступ к сетевому устройству (при помощи raw sockets). Такие «необработанные» сокеты может создавать только суперпользователь.    

###4.5.Файловая система.
**Часть информациии о файловой системе представлена в главе 6.**  
Для того чтобы приложения могли взаимодействовать с разными файловыми  системами, реализованными на разных типах локальных или удаленных устройств, в Linux принят использованный в других UNIX-системах подход — виртуальная файловая система Virtual File System (VFS). VFS определяет набор основных абстракций файловой системы и разрешенные с этими абстракциями операции. Описанные в предыдущем разделе системные вызовы обращаются к структурам данных VFS, определяют тип файловой системы (к которой принадлежит нужный файл) и при помощи хранящихся в структурах данных VFS указателей на функции запускают соответствующую операцию в указанной файловой системе.   
Далее рассмотрим поддерживаемые файловые системы в ArchLinux:  
 
**XFS** — начало разработки 1993 год, фирма Silicon Graphics, в мае 2000 года предстала в GNU GPL, для пользователей большинства Linux систем стала доступна в 2001-2002 гг. Отличительная черта системы — прекрасная поддержка больших файлов и файловых томов, 8 эксбибайт — 1 байт (8*260-1 байт) для 64-х битных систем. Ко всему прочему обладает другими немаловажными особенностями — непрерывные области дискового пространства, задержка выделения пространства и онлайн дефрагментация. Является одной из старейших журналируемых файловых систем для *nix, и содержит в себе наиболее отлаженный, в этом контексте, исходный код.  

**ReiserFS (Reiser3)** — одна из первых журналируемых файловых систем под Linux, разработана Namesys. Имеет некоторые врождённые головные боли, но в целом неплохая система, ведущая отсчёт дней своих с 2001 года. Оговорюсь, что смысл журналируемых систем заключается в дисковых транзакциях, которые последовательно пишутся в специальную зону диска (журнал, он же лог), перед тем как данные попадают в конечные точки файловой системы. Максимальный объём тома для этой системы равен 16 тебибайт (16*240 байт).

**JFS (Journaled File System)** — файловая система, детище IBM, явившееся миру в далёком 1990 году для ОС AIX (Advanced Interactive eXecutive). В виде первого стабильного релиза, для пользователей Linux, система стала доступна в 2001 году. Из плюсов системы — неплохая масштабируемость. Из минусов — не особо активная поддержка на протяжении всего жизненного цикла. Максимальный рамер тома 32 пэбибайта (32*250 байт).  

**ext (extended filesystem)** — появилась в апреле 1992 года, это была первая файловая система, изготовленная специально под нужды Linux ОС. Разработана Remy Card с целью преодолеть ограничения файловой системы Minix.  

**ext2 (second extended file system)** — была разработана Remy Card в 1993 году. Не журналируемая файловая система, это был основной её недостаток, который исправит ext3.   

**ext3 (third extended filesystem)** — по сути расширение исконной для Linux ext2, способное к журналированию. Разработана Стивеном Твиди (Stephen Tweedie) в 1999 году, включена в основное ядро Linux в ноябре 2001 года. На фоне других своих сослуживцев обладает более скромным размером пространства, до 4 тебибайт (4*240 байт) для 32-х разрядных систем. На данный момент является наиболее стабильной и поддерживаемой файловой системой в среде Linux.  

**Reiser4** — первая попытка создать файловую систему нового поколения для Linux. Впервые представленная в 2004 году, система включает в себя такие передовые технологии как транзакции, задержка выделения пространства, а так же встроенная возможность кодирования и сжатия данных. Ханс Рейзер (Hans Reiser), главный разработчик системы, рекламировал использовать своё детище непосредственно как БД с улучшенными метаданными. После того, как Ханс Рейзер был осуждён за убийство в 2008 году, дальнейшая судьба системы стала сомнительной.  

**ext4** — попытка создать 64-х битную ext3 способную поддерживать больший размер файловой системы (1 эксбибайт). Позже добавились возможности — непрерывные области дискового пространства, задержка выделения пространства, онлайн дефрагментация и прочие. Обеспечивается прямая совместимость с системой ext3 и ограниченная обратная совместимость при недоступной способности к непрерывным областям дискового пространства.  

**Btrfs (B-tree FS или Butter FS)** — проект изначально начатый компанией Oracle, впоследствии поддержанный большинством Linux систем. Многие считаеют систему эдаким ответом на ZFS. Ключевыми особенностями данной файловой системы являются технологии: copy-on-write, позволяющая сделать снимки областей диска (снапшоты), которые могут пригодится для последующего восстановления; контроль за целостностью данных и метаданных (с повышенной гарантией целостности); сжатие данных; оптимизированный режим для накопителей SSD (задаётся при монтировании) и прочие. Немаловажным фактором является возможность перехода с ext3 на Btrfs. С августа 2008 года данная система выпускается под GNU GPL.  

**Tux2** — известная, но так и не анонсированная публично файловая система. Создатель Дэниэл Филипс (Daniel Phillips), система базируется на алгоритме «Фазового Дерева», который как и журналирование защищает файловую систему от сбоев. Организована как надстройка на ext2.   

**Tux3** — наступая на пятки Btrfs, представлена новая файловая система. Система создана на основе FUSE (Filesystem in Userspace), специального модуля для создания файловых систем на *nix платформах. Данный проект ставит перед собой цель избавиться от привычного журналирования, взамен предлагая версионное восстановление (состояние в определённый промежуток времени). Преимуществом используемой в данном случае версионной системы, является способ описания изменений, где для каждого файла создаётся изменённая копия, а не переписывается текущая версия. Такой подход позволяет более гибко управлять версиями.   

**Xiafs** — задумка и разработка данной файловой системы принадлежат Frank Xia, основана на файловой системе MINIX. В настоящее время считается устаревшей и практически не используется. Наряду с ext2 разрабатывалась, как замена системе ext. В декабре 1993 года система была добавлена в стандартное ядро Linux. И хотя система обладала большей стабильностью и занимала меньше дискового пространства под контрольные структуры — она оказалась слабее ext2, ведущую роль сыграли ограничения максимальных размеров файла и раздела, а так же способность к дальнейшему расширению.   

**ZFS (Zettabyte File System)** — изначально созданная в Sun Microsystems файловая система, для небезызвестной операционной системы Solaris в 2005 году. Отличительные особенности — отсутствие фрагментации данных как таковой, возможности по управлению снапшотами (snapshots), пулами хранения (storage pools), варьируемый размер блоков, 64-х разрядный механизм контрольных сумм, а так же способность адресовать 128 бит информации! В Linux системах может использоваться посредствам FUSE.   



##5. Производительность операционной системы.  
Ресурс Phoronix провёл тестирование производительности дистрибутивов Fedora 17, Fedora 18-beta, Ubuntu 12.10, Linaro 12.12 и Arch Linux на системе PandaBoards на базе платформы Texas Instruments OMAP4460 с процессором ARMv7 Cortex-A9 1.2 Ghz. Результаты оказались неожиданными - обе протестированные версии Fedora заметно отстали от других дистрибутивов, в том числе от Arch Linux, который тестировался на процессоре с частотой 1 Ghz.  

Так как в Ubuntu используются наработки консорциума Linaro, который в свою очередь рассматривает Ubuntu в качестве эталонной платформы, то обычный выпуск Ubuntu и специализированная сборка Ubuntu со свежими изменениями от Linaro с точки зрения производительности показали близкие резульататы. Сборки Fedora 17 и 18-beta для OMAP4 во всех тестах (кодирование видео VP8 и x264, GraphicsMagick, Himeno, 7-Zip, C-Ray, Parallel Bzip2, Smallpt, LAME MP3, FFmpeg, OpenSSL, NAS Parallel Benchmark, Dolfyn, FFTE) почти в два раза отстали от Ubuntu/Linaro. Arch Linux показал средние показатели, заняв нишу между Ubuntu/Linaro и Fedora.  

##6. Безопасность операциооной системы.  
Суть политики Unix состоит в том, что пользователь сам определяет права доступа к своим файлам. Любой файл принадлежит только одному пользователю - *владельцу* этого файла. А первичная группа пользователя обычно определяет ту группу, которая будет установлена на файл.  
Для просмотра информации о файлах используют команду **ls -l**:  
    $ ls -l  
    $ -rw-rw-r-- 1 kanst9 kanst9   320 авг.   1 17:52 2012-08-03-prava.md  

В данном примере, в первом поле содержится тип файла и права доступа к нему. Первый символ - дефис, значит, что перед нами обычный файл. Также существуют другие разновидности файлов:  

+	Обычный файл **"-"**.
+	Каталог **"d"**.
+	Файл символьного устройства **"с"**.
+	Файл блочного устройства **"b"**.
+	Локальный сокет **"s"**.
+	Именованный канал **"p"**.
+	Символическая ссылка **"l"**.

Следующие девять символов определяют биты режима. Подробнее о них будут рассмотрены далее.  
Второе поле - количество жестких ссылок на файл. Далее идут владелец файла и группа. Потом указывается размер файла в байтах и дата последней модификации.

###6.1. Биты режима.
Правa доступа к файлу хранятся в метаданных файла. Задавать права можно в символической и восьмеричной записи.  
Первые три символа (*rw-*) определяют права доступа владельца файла. Следующие три (*rw-*) - права группы. А последние (*r--*) - права доступа остальных пользователей.   
Бит **"r"** (4 в восьмеричной нотации) - бит чтения. Он позволяет открывать и читать файл.  
Бит **"w"** (2 в восьмеричной нотации) - бит записи. Он позволяет изменять файл. Правом удалять и переименовывать управляют биты, заданные для его родительского каталога.  
Бит **"x"** (1 в восьмеричной нотации) - бит выполнения. Он позволяет запускать файл. Для каталога он разрешает переходить в каталог или проходить через него для доступа к файлу.  
В данном примере, запись *rw-rw-r--*(664) означает, что пользователь и группа имеют права на чтение и запись, а остальные пользователи только на чтение. Восьмеричное значение получается сложением степеней двойки, соответствующих номеру бита в триаде. Например, 6 = 4 + 2, 7 = 4 + 2 + 1, 5 = 4 + 1.  
Помимо битов, устанавливающих разрешение на доступ к файлу, существуют специальные атрибуты, для которых предназначена еще одна триада битов. Это **setuid** (обозначается **s**), **setguid** (обозначается **s**) и **sticky bit** (обозначается **t**). Если первые два установлены для исполняемых файлов, они позволяют программам получают получать доступ к тем файлам, которые при прочих обстоятельствах недоступны для них. В настоящее время **sticky bit** игнорируется. В первых Unix-системах он запрещал выгрузку программ из памяти.


###6.2 Изменение прав доступа с помощью команды chmod.
Правом изменять доступ к файлу имеют сам пользователь и суперпользователь.
Первый аргумент команды **chmod** - спецификация прав доступа. Он состоит из 3 цифр. Первая - бит пользователя, вторая - бит группы, третья - бит остальных пользователей. Если необходимо задать биты *setuid*, *setgid* или *sticky bit*, то следует указать четыре цифры. Первая будет определять специальные биты. Например:  

$ ls -l  
	-rw-rw-r-- 1 kanst9 kanst9 0 авг.   2 15:15 primer   
	//Пользователь и группа - чтение и запись, остальные - чтение  
	$ chmod 766  
	-rwxrw-rw- 1 kanst9 kanst9 0 авг.   2 15:15 primer   
	//Пользователь - все действия, группа и остальные - чтение и запись  
	$ chmod 6777  
	-rwsrwsrwx 1 kanst9 kanst9 0 авг.   2 15:15 primer  
	//Установлены *setuid* и *setgid*  

При использовании мнемонического синтаксиса используют символы:  

+	**u** - пользователь
+	**g** - группа
+	**o** - другие
+	**a** - все
+	**+** - добавить
+	**-** - удалить
+	**=** - присвоить

Рассмотрим синтаксис на примерах:	  
	$ ls -l  
	-rw-rw-r-- 1 kanst9 kanst9 0 авг.   2 15:15 primer   
	$ chmog u-w,g-rw   
	-r-----r-- 1 kanst9 kanst9 0 авг.   2 15:15 primer   
	$ chmod g=u  
	-r--r--r-- 1 kanst9 kanst9 0 авг.   2 15:15 primer   

Для изменения владельца файла и группы используют команды **chown** и **chgrp**:  
**chown** *пользователь файл*  
**chgrp** *пользователь файл*  
**chown** *пользователь:группа файл*  
Флаг **-R** позволяет рекурсивно изменять владельцев каталога и подкаталогов. 

###6.3 Стандартные права доступа с помощью команды umask.
При создании файла код доступа к нему устанавливается равным разнице между величиной, которую запрашивает создающая файл программа, и значением команды **umask**. Например команда **umask 013** даст файлу права *rwxrw-r--*.  
Стандартное значение **umask** можно установить в файле **.profile**, который предоставляется каждому пользователю системы.

###6.4 Дополнительные флаги систем ext*.
Для просмотра и изменения дополнительных флагов существуют команды **lsattr** и **chattr**. Полезные флаги рассмотрены ниже:

+	**а** - Запись в файл только в режиме добавления (устанавливается суперпользователем).  
+	**i** - Сделать файл неудаляемым и неизменяемым (устанавливается суперпользователем).
Синтаксис команды **chattr** подобен синтаксису **chmod**(-+=). Остальные флаги можно посмотреть с помощью команды **man chattr**.   

###6.5. Безопасность с помощью SELinux.  
В предыдущих пунктах были расмотренны традиционные варианты безопасности ArchLinux.  
SeLinux (англ. Security-Enhanced Linux — Linux с улучшенной безопасностью) - это реализация системы принудительного управления доступом, в которой все привилегии назначаются администратором. Пользователи не могут делегировать свои права и не могут устанавливать параметры контроля доступа на объекты, которыми они владеют.  

###6.6. Безопасность с помощью ACL.  
Списки управление дуступом (ACL - access control list) - это обобщение страдиционной модели "rwx", устанавливаемые сразу для нескольких пользователей и групп. Они являются частью реализации файловой системы, поэтому их поддержку должна обеспечивать файловая система. В общем, запись контроля доступа идентифицирует пользователя или группу, к которой она применяется, и определяет набор привилегий, которыми наделяются эти пользователи. Списки ACL не имеют фиксированной длины и могут содержать определения прав множества пользователей или групп. Большинство операционных систем ограничивает длину отдельного списка ACL, но это ограничение может быть довольно слабым (обычно 32 записи), которое достигается не часто. Списки ACL тяготеют к беспорядку, и поэтому со временем они становятся непригодными для управления.  

##7. Преимущества и недостатки.
Можно выделить следующие преимущества и недостатки:  
Недостатки:  

* Сложность в освоении новичком.  
* Достаточно трудоемкий процесс первой настройки.  
* Могут возникнуть проблемы с переносаом программ на Unix истемы из-за потоков.  
Преимущества:  

* Дружелюбное сообщество.  
* Цена целых 0$.  
* Максимальная гибкость в настройке.  
* Простота и прозрачность системы.Наличие ABS и AUR как альтернативных источников ПО.  
* Вы устанавливаете только то чем реально пользуетесь.  
* Достаточно быстрый дистрибутив, по производительности ничем не уступает Gentoo Linux.  


##8. Позиционирование на рынке.
Система имеет лицензию GNU GP  
GPL предоставляет получателям компьютерных программ следующие права, или «свободы»:  

* свободу запуска программы с любой целью;  
* свободу изучения того, как программа работает, и её модификации (предварительным условием для этого является доступ к исходному коду);  
* свободу распространения копий как исходного, так и исполняемого кода;  
* свободу улучшения программы, и выпуска улучшений в публичный доступ (предварительным условием для этого является доступ к исходному коду).  

В общем случае распространитель программы, полученной на условиях GPL, либо программы, основанной на таковой, обязан предоставить получателю возможность получить соответствующий исходный код.  

Систему является бесплатной и ее использую, в основном, пользователи, желающие гибко настроить свою рабочую станцию. Также возможно использование в виде серверной ОС.  

##9. Используемые источники информации.
Таненбаум - «Современные операционные системы», 3 издание  
Wikipedia EN - http://en.wikipedia.org/wiki  
Habrahabr - http://habrahabr.ru/  
UNIX and Linux System Administration Handbook (Unix и Linux. Руководство системного администратора), 4 издание   
http://blog.kanst9.com
