---
layout: post
title: Краткое описание процессов Linux.
category : lessons
tags : [Linux, process]
---


__________________________________

*Процесс* - это системный объект, посредством которого можно контролировать обращение программы к памяти, ЦП, к операциям ввода-вывода. Философия Unix подразумевает, что как можно больше работы должны выполняться в контексте процессов, а не в ядре.  
На выполнение процесса влияют многие характеристики. В частности, большое значение имеет, сколько времени выделяется процессу центральным процессором, к каким файлам обращается процесс, значение идентификатора родительского процесса. Эти и некоторые другие характеристики будут рассмотрены далее.  
<h1>Идентификатор процесса (PID) и идентификатор родительского процесса (PPID).</h1>
Каждый процесс имеет свой идентификатор. Идентификаторы назначаются ядром по мере создания процессов.  
В Unix нет вызовов, которые бы создавали новый процесс. Для того, чтобы создать новый процесс, один из существующих должен клонировать себя. При этом клон - дочерний процесс, а исходный процесс - родительский. Дочерний процесс может изменить выполняемую программу. При создании процесса, дочернему присваивается идентификатор родительского процесса (PPID), помимо обычного PID. Если родительский процесс завершится раньше дочернего, то шефство берет демон *init* (PPID дочернего процесса будет равен 1).  
Идентификатор родительского процесса - очень полезная информация для системного администратора. Если приходится иметь дело с неизвестным процессом, то отслеживание предка может облегчить понимание назначения этого процесса.

Также процесс имеет такие характеристики, как идентификатор пользователя (UID), текущий идентификатор пользователя (EUID), идентификатор группы (GID), текущий идентификатор группы (EGID).  

<h1>Фактор уступчивости и приоритет.</h1>
С помощью динамического алгоритма вычисления приоритета, ядро определяет, какую долю центрального процессора получает программа. Кроме того учитывается заданный администратором фактор уступчивости, который определяет возможность "деления" своим временем с другими процессами. Чем выше фактор уступчивости, тем ниже приоритет процесса. Диапазон значений зависит от используемой системы. Обычно лежит в пределах -20..+19 (0..39).  
В настоящее время администраторам редко приходится определять значение фактора уступчивости. Если какой-либо процесс занимает большое время ЦП, то для исследования проблемы (например, с помощью команды **top**) нужно повысить приоритет этой команды (понизить фактор уступчивости). 
Команда **nice** позволяет задать приоритет при создании процесса. **renice** же позволяет изменять приоритет выполняемого процесса.  
Примеры:    
	$ nice -n 5 top 		//Запускаем программу с пониженным приоритетом.
	$ renice -5 3456		//Фактор уступчивости процесса равен -5.
	$ renice -5 -u kanst9	//Фактор уступчивости процессов пользователя kanst9 равен -5.

<h1></h1>
<h1>Жизненный цикл процессов.</h1>  

Для создания нового процесса существующий процесс клонирует себя с помощью системного вызова **fork()**. При создании процесса ядро назначает ему уникальный PID и в значение PPID записывается идентификатор родительского процесса. Далее дочерний процесс запускает новую программу с помощью одного из системных вызовов семейства **exec()**.  
При завершении процесса он вызывает функцию **exit()**, для уведомления ядра о готовности завершить свою работу. При этом ядро требует, чтобы завершение было подтверждено родительским процессом (или демоном *init*, если родительский процесс уже завершил свою работу) с помощью системного вызова **wait()**.  
Процесс может существовать в четырех состояниях:  

*	**Выполнение** - процесс, который получил все необходимые ресурсы и ждет доступа к центральному процессору.  
*	**Ожидание** - процесс, который ожидает определенного события.  
*	**Зомби** - процесс, который уже завершил свою работу, но родительский не подтвердил завершения системным вызовом **wait()**.  
*	**Остановлен** - процесс, которому временно запрещено выполняться (получен сигнал **STOP** или **TSTP**).  
<h1></h1>
<h1>Сигналы.</h1>
Сигналы - один из способов межпроцессорного взаимодействия. Список сигналов можно получить с помощью команды **kill -l**. А их подробное описание с помощью команды **man signal**.
Рассмотрим самые популярные сигналы:

+	1 - **HUP** - отбой (многие демоны используют этот сигнал, как команду перечитать их конфигурационный файл и продолжить работу с измененными настройками).  
+	2 - **INT** - прерывание (генерируется нажатием клавиш <Ctrl+C>).  
+	3 - **QUIT** - выход (напоминает сигнал **TERM**, только создается дамп памяти).  
+	9 - **KILL** - уничтожение (этот сигнал не блокируется и не перехватывается и приводит к безусловному завершению процесса).  
+	  - **BUS** и **SEGV** - посылаются при возникновении ошибок на шине и ошибок сегментации.  
+	15 - **TERM** - запрос на завершение (процесс, получивший этот сигнал, осуществляет очистку и завершается).  
+	  - **STOP** - остановка (приостанавливает процесс до получения сигнала **CONT**, нельзя перехватить и заблокировать).  
+	  - **TSTP** - остановка с клавиатуры (посылается нажатием клавиш <Ctrl+Z>).
+	  - **CONT** - продолжение после останова (нельзя заблокировать).  

Чтобы послать сигнал часто используют команду **kill**. Она имеет следующий синтаксис:  
	kill [-сигнал]  идентификатор.
Команда killall уничтожает процессы, заданные именем.
	$ killall top 

С помощью команды **trap** можно перехватывать сигналы. Рассмотрим на примере:

	$ trap "echo Получен сигнал INT" INT
	$ <Ctrl+C>
	$ Получен сигнал INT
<h1></h1>  
<h1>Фоновый режим выполнения.</h1>
Для запуска команды в фоновом режиме после команды добавляется знак "&":
	$ top &
	[1] 3058
	$ htop &
	[2] 3061
Значение в квадратных скобках - номер задания, число - PID процесса.
Просмотреть фоновые задачи можно с помощью команды **jobs**:
	$ jobs
	[1]  - suspended (tty output)  top
	[2]  + suspended (tty output)  htop
Знак "-" показывает предпоследнее задание, а знак "+" - последнее.
Команда **fg %номер задания** переводит задание в интерактивный режим. Вместо *номер задания* можно использовать первые буквы задачи.  
Для обратного перевода в фоновый режим необходимо приостановить программу (послать сигнал **STOP** с помощью комбинации клавиш <Ctrl+Z>) и выполнить команду **bg %номер задания**.  
Для завершения задания используют команду **kill %номер задания**.  

<h1>Контроль процессов.</h1>
Получить список всех процессов можно с помощью команды **ps aux**. Ключ **a** используется для получения всех процессов, **x** - для отображения процессов, отсоединенных от терминала, **u** - фильтрование по имени.  
Еще один набор аргументов - **lax**. Ключ **l** используется для более подробного вывода. С этим ключом вывод происходит быстрее, т.к. не происходит сортировка.  
Команды **w** выводит список пользователей, вошедших в систему и список выполняющихся заданий.
	$ w
	 19:14:16 up  2:41,  2 users,  load average: 0,52, 0,57, 0,50
	USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT
	kanst9   pts/0    :0               16:34    2:39m 28.33s 27.54s /usr/bin/ruby1.
	kanst9   pts/1    :0.0             18:54    0.00s  0.74s  0.00s w

Для динамического мониторинга процессов используют команду **top**:
	$ top
	top - 19:19:55 up  2:46,  2 users,  load average: 0.60, 0.58, 0.52
	Tasks: 173 total,   1 running, 171 sleeping,   1 stopped,   0 zombie
	Cpu(s):  2.0%us,  3.0%sy,  0.0%ni, 93.1%id,  1.9%wa,  0.0%hi,  0.0%si,  0.0%st
	Mem:   4124348k total,  1180112k used,  2944236k free,    70880k buffers
	Swap:   999420k total,        0k used,   999420k free,   496696k cached

	  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND            
	 1292 root      20   0  272m 110m  73m S    9  2.8   3:43.10 Xorg               
	 3003 kanst9    20   0 97072  16m  11m S    2  0.4   0:02.61 gnome-terminal     
	 1869 kanst9    20   0  150m  13m  10m S    1  0.3   0:20.83 metacity           
	 3146 kanst9    20   0  2836 1148  860 R    1  0.0   0:00.02 top                
	  241 root      20   0     0    0    0 S    0  0.0   0:00.22 jbd2/sda6-8        
	 2253 kanst9    20   0  173m  42m  15m S    0  1.0   1:36.55 sublime_text       
	    1 root      20   0  3520 1928 1248 S    0  0.0   0:00.67 init               
	    2 root      20   0     0    0    0 S    0  0.0   0:00.00 kthreadd           
	    3 root      20   0     0    0    0 S    0  0.0   0:00.16 ksoftirqd/0        
	    6 root      RT   0     0    0    0 S    0  0.0   0:00.00 migration/0        
	    7 root      RT   0     0    0    0 S    0  0.0   0:00.04 watchdog/0         
	    8 root      RT   0     0    0    0 S    0  0.0   0:00.00 migration/1        
	   10 root      20   0     0    0    0 S    0  0.0   0:00.02 ksoftirqd/1        
	   12 root      RT   0     0    0    0 S    0  0.0   0:00.03 watchdog/1         
	   13 root       0 -20     0    0    0 S    0  0.0   0:00.00 cpuset             
	   14 root       0 -20     0    0    0 S    0  0.0   0:00.00 khelper            
	   15 root      20   0     0    0    0 S    0  0.0   0:00.00 kdevtmpfs          
Более подробно про эту команду можно прочитать с помощью *man top*

Команды **ps** и **top** считывают информацию из каталога **/proc**. Большинство файлов этого каталога выглядят пустыми, так как ядро создает содержимое на лету. Рассмотрим содержимое каталога **/proc**.  

+	**cmdline** - Полная командная строка процесса.  
+	**cwd** - Символьная ссылка на текущий каталог процесса.  
+	**exe** - Символьная ссылка на файл, который должен выполняться.  
+	**fd** - Подкаталог, содержащий ссылки на дескрипторы каждого открытого файла.  
+	**maps** - Информация отображения памяти.  
+	**root** - Символьная ссылка на корневой каталог процесса.  
+	**stat** - Информация об общем состоянии процесса.  
+	**statm** - Информация об используемой памяти.  

Более подробно про каталог **/proc** можно посмотреть с помощью команды **man proc**.

